package agents_test

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/nlpodyssey/openai-agents-go/agents"
	"github.com/openai/openai-go/v3/packages/param"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type Weather struct {
	City             string `json:"city"`
	TemperatureRange string `json:"temperature_range"`
	Conditions       string `json:"conditions"`
}

type GetWeatherArgs struct {
	City string `json:"city"`
}

func GetWeather(_ context.Context, args GetWeatherArgs) (Weather, error) {
	return Weather{
		City:             args.City,
		TemperatureRange: "14-20C",
		Conditions:       "Sunny with wind.",
	}, nil
}

func TestGetWeatherTool_Manual(t *testing.T) {
	GetWeatherTool := agents.FunctionTool{
		Name:        "get_weather",
		Description: "",
		ParamsJSONSchema: map[string]any{
			"type":                 "object",
			"required":             []string{"city"},
			"additionalProperties": false,
			"properties": map[string]any{
				"city": map[string]any{
					"type": "string",
				},
			},
		},
		OnInvokeTool: func(ctx context.Context, arguments string) (any, error) {
			var args GetWeatherArgs
			err := json.Unmarshal([]byte(arguments), &args)
			if err != nil {
				return nil, err
			}
			return GetWeather(ctx, args)
		},
		StrictJSONSchema: param.NewOpt(true),
	}

	t.Run("ManualTool_BasicProperties", func(t *testing.T) {
		assert.Equal(t, "get_weather", GetWeatherTool.ToolName())
		assert.Equal(t, "", GetWeatherTool.Description)
		assert.True(t, GetWeatherTool.StrictJSONSchema.Value)
	})

	t.Run("ManualTool_Schema", func(t *testing.T) {
		schema := GetWeatherTool.ParamsJSONSchema

		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])
		assert.Equal(t, []string{"city"}, schema["required"])

		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)

		cityProp, ok := properties["city"].(map[string]any)
		require.True(t, ok)
		assert.Equal(t, "string", cityProp["type"])
	})

	t.Run("ManualTool_Invocation", func(t *testing.T) {
		args := `{"city": "Tokyo"}`
		result, err := GetWeatherTool.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)
		weather, ok := result.(Weather)
		require.True(t, ok)

		assert.Equal(t, "Tokyo", weather.City)
		assert.Equal(t, "14-20C", weather.TemperatureRange)
		assert.Equal(t, "Sunny with wind.", weather.Conditions)
	})
}

func TestGetWeatherTool_NewFunctionTool(t *testing.T) {
	GetWeatherToolNew := agents.NewFunctionTool("get_weather", "", GetWeather)

	t.Run("AutoTool_BasicProperties", func(t *testing.T) {
		assert.Equal(t, "get_weather", GetWeatherToolNew.ToolName())
		assert.Equal(t, "", GetWeatherToolNew.Description) // Empty description
		assert.True(t, GetWeatherToolNew.StrictJSONSchema.Value)
	})

	t.Run("AutoTool_GeneratedSchema", func(t *testing.T) {
		schema := GetWeatherToolNew.ParamsJSONSchema

		// Auto-generated schema structure
		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])

		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)

		cityProp, ok := properties["city"].(map[string]any)
		require.True(t, ok)
		assert.Equal(t, "string", cityProp["type"])

		// Check required fields
		required, ok := schema["required"].([]any)
		require.True(t, ok)
		// Convert to string slice for easier assertion
		var requiredStrings []string
		for _, r := range required {
			requiredStrings = append(requiredStrings, r.(string))
		}
		assert.Contains(t, requiredStrings, "city")
	})

	t.Run("AutoTool_Invocation", func(t *testing.T) {
		args := `{"city": "Tokyo"}`
		result, err := GetWeatherToolNew.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)

		// Result should be a Weather
		_, ok := result.(Weather)
		require.True(t, ok)
	})
}

func TestManualVsAutoGenerated_SchemaDifferences(t *testing.T) {
	// Create both tools for comparison
	manualTool := agents.FunctionTool{
		Name:        "get_weather",
		Description: "",
		ParamsJSONSchema: map[string]any{
			"type":                 "object",
			"required":             []string{"city"},
			"additionalProperties": false,
			"properties": map[string]any{
				"city": map[string]any{
					"type": "string",
				},
			},
		},
		OnInvokeTool: func(ctx context.Context, arguments string) (any, error) {
			var args GetWeatherArgs
			err := json.Unmarshal([]byte(arguments), &args)
			if err != nil {
				return nil, err
			}
			return GetWeather(ctx, args)
		},
		StrictJSONSchema: param.NewOpt(true),
	}

	autoTool := agents.NewFunctionTool("get_weather", "", GetWeather)

	t.Run("SchemaDifferences", func(t *testing.T) {
		manualSchema := manualTool.ParamsJSONSchema
		autoSchema := autoTool.ParamsJSONSchema

		// Both should have the same basic structure
		assert.Equal(t, "object", manualSchema["type"])
		assert.Equal(t, "object", autoSchema["type"])
		assert.Equal(t, false, manualSchema["additionalProperties"])
		assert.Equal(t, false, autoSchema["additionalProperties"])

		manualProps := manualSchema["properties"].(map[string]any)
		autoProps := autoSchema["properties"].(map[string]any)

		manualCity := manualProps["city"].(map[string]any)
		autoCity := autoProps["city"].(map[string]any)

		// Both should have same type
		assert.Equal(t, "string", manualCity["type"])
		assert.Equal(t, "string", autoCity["type"])
	})

	t.Run("FunctionalEquivalence", func(t *testing.T) {
		// Both tools should produce the same results when invoked
		args := `{"city": "Paris"}`

		manualWeather, err1 := manualTool.OnInvokeTool(t.Context(), args)
		autoWeather, err2 := autoTool.OnInvokeTool(t.Context(), args)

		require.NoError(t, err1)
		require.NoError(t, err2)

		assert.Equal(t, manualWeather, autoWeather)
	})
}

func TestFunction_ErrorHandling(t *testing.T) {
	tool := agents.NewFunctionTool("test_tool", "Test tool", GetWeather)

	t.Run("InvalidJSON", func(t *testing.T) {
		// Invalid JSON should return error
		args := `{"city": "Tokyo"`
		_, err := tool.OnInvokeTool(t.Context(), args)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to parse arguments")
	})

	t.Run("MissingRequiredField", func(t *testing.T) {
		// Missing city field should still work (JSON unmarshaling will use zero value)
		args := `{}`
		result, err := tool.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)

		// Result should be a Weather
		weather, ok := result.(Weather)
		require.True(t, ok)

		// City should be empty string (zero value)
		assert.Equal(t, "", weather.City)
	})
}

func TestNewFunctionTool_EmptyStructArgs(t *testing.T) {
	type emptyStruct struct{}
	handler := func(ctx context.Context, args emptyStruct) (string, error) {
		return "ok", nil
	}

	tool := agents.NewFunctionTool("empty_tool", "", handler)

	t.Run("Schema", func(t *testing.T) {
		schema := tool.ParamsJSONSchema
		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])
		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)
		assert.Len(t, properties, 0)
		assert.Equal(t, []any{}, schema["required"]) // strict is enforced
	})

	t.Run("Invocation", func(t *testing.T) {
		result, err := tool.OnInvokeTool(t.Context(), `{}`)
		require.NoError(t, err)
		assert.Equal(t, "ok", result.(string))
	})
}

func TestFunctionTool_IsEnabled(t *testing.T) {
	type BoolCtx struct {
		EnableTools bool
	}

	type boolCtxKey struct{}

	disabledTool := agents.NewFunctionTool("disabled_tool", "", func(context.Context, struct{}) (string, error) {
		return "nope", nil
	})
	disabledTool.IsEnabled = agents.FunctionToolDisabled()

	anotherTool := agents.NewFunctionTool("another_tool", "", func(context.Context, struct{}) (string, error) {
		return "hi", nil
	})
	anotherTool.IsEnabled = agents.FunctionToolEnablerFunc(func(ctx context.Context, _ *agents.Agent) (bool, error) {
		return ctx.Value(boolCtxKey{}).(*BoolCtx).EnableTools, nil
	})

	thirdTool := agents.FunctionTool{
		Name:             "third_tool",
		Description:      "third tool",
		ParamsJSONSchema: nil,
		OnInvokeTool: func(context.Context, string) (any, error) {
			return "third", nil
		},
		IsEnabled: agents.FunctionToolEnablerFunc(func(ctx context.Context, _ *agents.Agent) (bool, error) {
			return ctx.Value(boolCtxKey{}).(*BoolCtx).EnableTools, nil
		}),
	}

	agent := agents.New("t").WithTools(disabledTool, anotherTool, thirdTool)

	ctx1 := context.WithValue(t.Context(), boolCtxKey{}, &BoolCtx{EnableTools: false})
	ctx2 := context.WithValue(t.Context(), boolCtxKey{}, &BoolCtx{EnableTools: true})

	toolsWithCtx, err := agent.GetAllTools(ctx1)
	require.NoError(t, err)
	assert.Empty(t, toolsWithCtx)

	toolsWithCtx, err = agent.GetAllTools(ctx2)
	require.NoError(t, err)
	assert.Len(t, toolsWithCtx, 2)
	assert.Equal(t, "another_tool", toolsWithCtx[0].ToolName())
	assert.Equal(t, "third_tool", toolsWithCtx[1].ToolName())
}
