// Copyright 2025 The NLP Odyssey Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package agents

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"slices"
	"sync"

	"github.com/nlpodyssey/openai-agents-go/asyncqueue"
	"github.com/nlpodyssey/openai-agents-go/modelsettings"
	"github.com/nlpodyssey/openai-agents-go/openaitypes"
	"github.com/nlpodyssey/openai-agents-go/runcontext"
	"github.com/nlpodyssey/openai-agents-go/types/optional"
	"github.com/openai/openai-go/responses"
	"github.com/openai/openai-go/shared/constant"
)

type queueCompleteSentinel struct{}

func (queueCompleteSentinel) isStreamEvent() {}

var notFinalOutput = ToolsToFinalOutputResult{
	IsFinalOutput: false,
	FinalOutput:   optional.None[any](),
}

type AgentToolUseTracker struct {
	AgentToTools []AgentToToolsItem
}

func NewAgentToolUseTracker() *AgentToolUseTracker {
	return &AgentToolUseTracker{}
}

type AgentToToolsItem struct {
	Agent     *Agent
	ToolNames []string
}

func (item *AgentToToolsItem) AppendToolNames(toolNames []string) {
	item.ToolNames = append(item.ToolNames, toolNames...)
}

func (t *AgentToolUseTracker) AddToolUse(agent *Agent, toolNames []string) {
	index := t.agentIndex(agent)
	if index == -1 {
		t.AgentToTools = append(t.AgentToTools, AgentToToolsItem{
			Agent:     agent,
			ToolNames: toolNames,
		})
	} else {
		t.AgentToTools[index].AppendToolNames(toolNames)
	}
}

func (t *AgentToolUseTracker) HasUsedTools(agent *Agent) bool {
	index := t.agentIndex(agent)
	return index != -1 && len(t.AgentToTools[index].ToolNames) > 0
}

func (t *AgentToolUseTracker) agentIndex(agent *Agent) int {
	return slices.IndexFunc(t.AgentToTools, func(item AgentToToolsItem) bool {
		return item.Agent == agent
	})
}

type ToolRunHandoff struct {
	Handoff  Handoff
	ToolCall ResponseFunctionToolCall
}

type ToolRunFunction struct {
	ToolCall     ResponseFunctionToolCall
	FunctionTool FunctionTool
}

type ProcessedResponse struct {
	NewItems  []RunItem
	Handoffs  []ToolRunHandoff
	Functions []ToolRunFunction
	// Names of all tools used, including hosted tools
	ToolsUsed []string
}

func (pr *ProcessedResponse) HasToolsToRun() bool {
	// Handoffs, functions actions need local processing
	// Hosted tools have already run, so there's nothing to do.
	return len(pr.Handoffs) > 0 || len(pr.Functions) > 0
}

type NextStep interface {
	isNextStep()
}

type NextStepHandoff struct {
	NewAgent *Agent
}

func (NextStepHandoff) isNextStep() {}

type NextStepFinalOutput struct {
	Output any
}

func (NextStepFinalOutput) isNextStep() {}

type NextStepRunAgain struct{}

func (NextStepRunAgain) isNextStep() {}

type SingleStepResult struct {
	// The input items i.e. the items before Run() was called. May be mutated by handoff input filters.
	OriginalInput Input

	// The model response for the current step.
	ModelResponse ModelResponse

	// Items generated before the current step.
	PreStepItems []RunItem

	// Items generated during this current step.
	NewStepItems []RunItem

	// The next step to take.
	NextStep NextStep
}

// GeneratedItems returns the items generated during the agent run (i.e. everything generated after `OriginalInput`).
func (result SingleStepResult) GeneratedItems() []RunItem {
	return slices.Concat(result.PreStepItems, result.NewStepItems)
}

type runImpl struct{}

func RunImpl() runImpl { return runImpl{} }

func (ri runImpl) ExecuteToolsAndSideEffects(
	ctx context.Context,
	agent *Agent,
	// The original input to the Runner
	originalInput Input,
	// Everything generated by Runner since the original input, but before the current step
	preStepItems []RunItem,
	newResponse ModelResponse,
	processedResponse ProcessedResponse,
	outputSchema AgentOutputSchemaInterface,
	hooks RunHooks,
	contextWrapper *runcontext.RunContextWrapper,
	runConfig RunConfig,
) (*SingleStepResult, error) {
	// Make a copy of the generated items
	preStepItems = slices.Clone(preStepItems)

	var newStepItems []RunItem
	newStepItems = append(newStepItems, processedResponse.NewItems...)

	// First, let's run the tool calls - function tools
	functionResults, err := ri.ExecuteFunctionToolCalls(
		ctx,
		agent,
		processedResponse.Functions,
		hooks,
		contextWrapper,
	)
	if err != nil {
		return nil, err
	}

	for _, result := range functionResults {
		newStepItems = append(newStepItems, result.RunItem)
	}

	// Second, check if there are any handoffs
	if runHandoffs := processedResponse.Handoffs; len(runHandoffs) > 0 {
		return ri.ExecuteHandoffs(
			ctx,
			agent,
			originalInput,
			preStepItems,
			newStepItems,
			newResponse,
			runHandoffs,
			hooks,
			contextWrapper,
			runConfig,
		)
	}

	// Third, we'll check if the tool use should result in a final output
	checkToolUse, err := ri.checkForFinalOutputFromTools(
		agent,
		functionResults,
		contextWrapper,
	)
	if err != nil {
		return nil, err
	}

	if checkToolUse.IsFinalOutput {
		// If the output type is str, then let's just stringify it
		if !checkToolUse.FinalOutput.Present {
			slog.Error("Model returned a final output of None. Not raising an error because we assume you know what you're doing.")
		}

		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			checkToolUse.FinalOutput.ValueOrFallback(nil),
			hooks,
			contextWrapper,
		)
	}

	// Now we can check if the model also produced a final output
	messageItems := make([]MessageOutputItem, 0)
	for _, item := range newStepItems {
		if messageItem, ok := item.(MessageOutputItem); ok {
			messageItems = append(messageItems, messageItem)
		}
	}

	// We'll use the last content output as the final output
	potentialFinalOutputText := optional.None[string]()
	if len(messageItems) > 0 {
		rawItem := messageItems[len(messageItems)-1].RawItem
		potentialFinalOutputText = ItemHelpers().ExtractLastText(openaitypes.ResponseOutputItemUnionFromResponseOutputMessage(rawItem))
	}

	// There are two possibilities that lead to a final output:
	// 1. Structured output schema => always leads to a final output
	// 2. Plain text output schema => only leads to a final output if there are no tool calls
	if outputSchema != nil && !outputSchema.IsPlainText() && potentialFinalOutputText.Present {
		finalOutput, err := outputSchema.ValidateJSON(potentialFinalOutputText.Value)
		if err != nil {
			return nil, fmt.Errorf("final output schema validation failed: %w", err)
		}
		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			finalOutput,
			hooks,
			contextWrapper,
		)
	} else if (outputSchema == nil || outputSchema.IsPlainText()) && !processedResponse.HasToolsToRun() {
		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			potentialFinalOutputText.ValueOrFallback(""),
			hooks,
			contextWrapper,
		)
	} else {
		// If there's no final output, we can just run again
		return &SingleStepResult{
			OriginalInput: originalInput,
			ModelResponse: newResponse,
			PreStepItems:  preStepItems,
			NewStepItems:  newStepItems,
			NextStep:      NextStepRunAgain{},
		}, nil
	}
}

// MaybeResetToolChoice resets tool choice to None if the agent has used tools and the agent's reset_tool_choice
// flag is True.
func (runImpl) MaybeResetToolChoice(
	agent *Agent,
	toolUseTracker *AgentToolUseTracker,
	modelSettings modelsettings.ModelSettings,
) modelsettings.ModelSettings {
	resetToolChoice := agent.ResetToolChoice.ValueOrFallback(true)
	if resetToolChoice && toolUseTracker.HasUsedTools(agent) {
		newSettings := modelSettings
		newSettings.ToolChoice = ""
		return newSettings
	}
	return modelSettings
}

func (runImpl) ProcessModelResponse(
	agent *Agent,
	allTools []Tool,
	response ModelResponse,
	handoffs []Handoff,
) (*ProcessedResponse, error) {
	var (
		items       []RunItem
		runHandoffs []ToolRunHandoff
		functions   []ToolRunFunction
		toolsUsed   []string
	)

	handoffMap := make(map[string]Handoff, len(handoffs))
	for _, handoff := range handoffs {
		handoffMap[handoff.ToolName] = handoff
	}

	functionMap := make(map[string]FunctionTool)
	for _, tool := range allTools {
		if functionTool, ok := tool.(FunctionTool); ok {
			functionMap[functionTool.Name] = functionTool
		}
	}

	for _, outputUnion := range response.Output {
		switch outputUnion.Type {
		case "message":
			output := responses.ResponseOutputMessage{
				ID:      outputUnion.ID,
				Content: outputUnion.Content,
				Role:    outputUnion.Role,
				Status:  responses.ResponseOutputMessageStatus(outputUnion.Status),
				Type:    constant.ValueOf[constant.Message](),
			}
			items = append(items, MessageOutputItem{
				Agent:   agent,
				RawItem: output,
				Type:    "message_output_item",
			})
		case "reasoning":
			output := responses.ResponseReasoningItem{
				ID:      outputUnion.ID,
				Summary: outputUnion.Summary,
				Type:    constant.ValueOf[constant.Reasoning](),
				Status:  responses.ResponseReasoningItemStatus(outputUnion.Status),
			}
			items = append(items, ReasoningItem{
				Agent:   agent,
				RawItem: output,
				Type:    "reasoning_item",
			})
		case "function_call":
			output := responses.ResponseFunctionToolCall{
				Arguments: outputUnion.Arguments,
				CallID:    outputUnion.CallID,
				Name:      outputUnion.Name,
				Type:      constant.ValueOf[constant.FunctionCall](),
				ID:        outputUnion.ID,
				Status:    responses.ResponseFunctionToolCallStatus(outputUnion.Status),
			}

			toolsUsed = append(toolsUsed, output.Name)

			// Handoffs
			if handoff, ok := handoffMap[output.Name]; ok {
				items = append(items, HandoffCallItem{
					Agent:   agent,
					RawItem: output,
					Type:    "handoff_call_item",
				})
				runHandoffs = append(runHandoffs, ToolRunHandoff{
					Handoff:  handoff,
					ToolCall: ResponseFunctionToolCall(output),
				})
			} else { // Regular function tool call
				functionTool, ok := functionMap[output.Name]
				if !ok {
					return nil, ModelBehaviorErrorf("Tool %s not found in agent %s", output.Name, agent.Name)
				}
				items = append(items, ToolCallItem{
					Agent:   agent,
					RawItem: ResponseFunctionToolCall(output),
					Type:    "tool_call_item",
				})
				functions = append(functions, ToolRunFunction{
					ToolCall:     ResponseFunctionToolCall(output),
					FunctionTool: functionTool,
				})
			}
		default:
			slog.Warn(fmt.Sprintf("unexpected output type, ignoring %q", outputUnion.Type))
		}
	}

	return &ProcessedResponse{
		NewItems:  items,
		Handoffs:  runHandoffs,
		Functions: functions,
		ToolsUsed: toolsUsed,
	}, nil
}

func (runImpl) ExecuteFunctionToolCalls(
	ctx context.Context,
	agent *Agent,
	toolRuns []ToolRunFunction,
	hooks RunHooks,
	contextWrapper *runcontext.RunContextWrapper,
) ([]FunctionToolResult, error) {
	runSingleTool := func(
		ctx context.Context,
		funcTool FunctionTool,
		toolCall ResponseFunctionToolCall,
	) (any, error) {
		var (
			hooksErrors [2]error
			toolError   error
			result      any
		)

		childCtx, cancel := context.WithCancel(ctx)
		defer cancel()

		var wg sync.WaitGroup

		wg.Add(1)
		go func() {
			defer wg.Done()
			err := hooks.OnToolStart(childCtx, contextWrapper, agent, funcTool)
			if err != nil {
				cancel()
				hooksErrors[0] = fmt.Errorf("RunHooks.OnToolStart failed: %w", err)
			}
		}()

		if agent.Hooks != nil {
			wg.Add(1)
			go func() {
				defer wg.Done()
				err := agent.Hooks.OnToolStart(childCtx, contextWrapper, agent, funcTool)
				if err != nil {
					cancel()
					hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolStart failed: %w", err)
				}
			}()
		}

		wg.Add(1)
		go func() {
			defer wg.Done()
			result, toolError = funcTool.OnInvokeTool(childCtx, contextWrapper, toolCall.Arguments)
			if toolError != nil {
				cancel()
			}
		}()

		wg.Wait()

		if err := errors.Join(hooksErrors[:]...); err != nil {
			return nil, err
		}
		if toolError != nil {
			return nil, fmt.Errorf("error running tool %s: %w", funcTool.Name, toolError)
		}

		wg.Add(1)
		go func() {
			defer wg.Done()
			err := hooks.OnToolEnd(childCtx, contextWrapper, agent, funcTool, result)
			if err != nil {
				cancel()
				hooksErrors[0] = fmt.Errorf("RunHooks.OnToolEnd failed: %w", err)
			}
		}()

		if agent.Hooks != nil {
			wg.Add(1)
			go func() {
				defer wg.Done()
				err := agent.Hooks.OnToolEnd(childCtx, contextWrapper, agent, funcTool, result)
				if err != nil {
					cancel()
					hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolEnd failed: %w", err)
				}
			}()
		}

		wg.Wait()
		if err := errors.Join(hooksErrors[:]...); err != nil {
			return nil, err
		}
		return result, nil
	}

	results := make([]any, len(toolRuns))
	resultErrors := make([]error, len(toolRuns))

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(len(toolRuns))

	for i, toolRun := range toolRuns {
		go func() {
			defer wg.Done()
			results[i], resultErrors[i] = runSingleTool(childCtx, toolRun.FunctionTool, toolRun.ToolCall)
			if resultErrors[i] != nil {
				cancel()
			}
		}()
	}

	wg.Wait()
	if err := errors.Join(resultErrors...); err != nil {
		return nil, err
	}

	functionToolResults := make([]FunctionToolResult, len(results))
	for i, result := range results {
		toolRun := toolRuns[i]

		// TODO: the original code does `str(result)`. What to do here? Should we try to marshal to JSON if it's not already a string?
		var strResult string
		switch v := result.(type) {
		case string:
			strResult = v
		case fmt.Stringer:
			strResult = v.String()
		default:
			strResult = fmt.Sprintf("%v", v)
		}

		functionToolResults[i] = FunctionToolResult{
			Tool:   toolRun.FunctionTool,
			Output: result,
			RunItem: ToolCallOutputItem{
				Agent:   agent,
				RawItem: ItemHelpers().ToolCallOutputItem(toolRun.ToolCall, strResult),
				Output:  result,
				Type:    "tool_call_output_item",
			},
		}
	}

	return functionToolResults, nil
}

func (runImpl) ExecuteHandoffs(
	ctx context.Context,
	agent *Agent,
	originalInput Input,
	preStepItems []RunItem,
	newStepItems []RunItem,
	newResponse ModelResponse,
	runHandoffs []ToolRunHandoff,
	hooks RunHooks,
	contextWrapper *runcontext.RunContextWrapper,
	runConfig RunConfig,
) (*SingleStepResult, error) {
	// If there is more than one handoff, add tool responses that reject those handoffs
	multipleHandoffs := len(runHandoffs) > 1

	if multipleHandoffs {
		const outputMessage = "Multiple handoffs detected, ignoring this one."
		for _, handoff := range runHandoffs[1:] {
			newStepItems = append(newStepItems, ToolCallOutputItem{
				Agent:   agent,
				RawItem: ItemHelpers().ToolCallOutputItem(handoff.ToolCall, outputMessage),
				Output:  outputMessage,
				Type:    "tool_call_output_item",
			})
		}
	}

	actualHandoff := runHandoffs[0]
	handoff := actualHandoff.Handoff
	newAgent, err := handoff.OnInvokeHandoff(ctx, contextWrapper, actualHandoff.ToolCall.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to invoke handoff: %w", err)
	}

	// Append a tool output item for the handoff
	toolCallOutputItem := ItemHelpers().ToolCallOutputItem(
		actualHandoff.ToolCall,
		handoff.GetTransferMessage(newAgent),
	)
	newStepItems = append(newStepItems, HandoffOutputItem{
		Agent: agent,
		RawItem: TResponseInputItem{
			OfFunctionCallOutput: &toolCallOutputItem,
		},
		SourceAgent: agent,
		TargetAgent: newAgent,
		Type:        "handoff_output_item",
	})

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Execute handoff hooks
	var wg sync.WaitGroup
	var handoffErrors [2]error

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnHandoff(childCtx, contextWrapper, agent, newAgent)
		if err != nil {
			cancel()
			handoffErrors[0] = fmt.Errorf("RunHooks.OnHandoff failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnHandoff(childCtx, contextWrapper, newAgent, agent)
			if err != nil {
				cancel()
				handoffErrors[0] = fmt.Errorf("AgentHooks.OnHandoff failed: %w", err)
			}
		}()
	}

	wg.Wait()
	if err = errors.Join(handoffErrors[:]...); err != nil {
		return nil, err
	}

	// If there's an input filter, filter the input for the next agent
	inputFilter := handoff.InputFilter
	if inputFilter == nil {
		inputFilter = runConfig.HandoffInputFilter
	}
	if inputFilter != nil {
		slog.Debug("Filtering inputs for handoff")
		handoffInputData := HandoffInputData{
			InputHistory:    CopyGeneralInput(originalInput),
			PreHandoffItems: slices.Clone(preStepItems),
			NewItems:        slices.Clone(newStepItems),
		}
		filtered, err := inputFilter(ctx, handoffInputData)
		if err != nil {
			return nil, fmt.Errorf("handoff input filter error: %w", err)
		}

		originalInput = CopyGeneralInput(filtered.InputHistory)
		preStepItems = slices.Clone(filtered.PreHandoffItems)
		newStepItems = slices.Clone(filtered.NewItems)
	}

	return &SingleStepResult{
		OriginalInput: originalInput,
		ModelResponse: newResponse,
		PreStepItems:  preStepItems,
		NewStepItems:  newStepItems,
		NextStep:      NextStepHandoff{NewAgent: newAgent},
	}, nil
}

func (ri runImpl) ExecuteFinalOutput(
	ctx context.Context,
	agent *Agent,
	originalInput Input,
	newResponse ModelResponse,
	preStepItems []RunItem,
	newStepItems []RunItem,
	finalOutput any,
	hooks RunHooks,
	contextWrapper *runcontext.RunContextWrapper,
) (*SingleStepResult, error) {
	// Run the onEnd hooks
	err := ri.RunFinalOutputHooks(ctx, agent, hooks, contextWrapper, finalOutput)
	if err != nil {
		return nil, err
	}

	return &SingleStepResult{
		OriginalInput: originalInput,
		ModelResponse: newResponse,
		PreStepItems:  preStepItems,
		NewStepItems:  newStepItems,
		NextStep:      NextStepFinalOutput{Output: finalOutput},
	}, nil
}

func (ri runImpl) RunFinalOutputHooks(
	ctx context.Context,
	agent *Agent,
	hooks RunHooks,
	contextWrapper *runcontext.RunContextWrapper,
	finalOutput any,
) error {
	var hooksErrors [2]error

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnAgentEnd(childCtx, contextWrapper, agent, finalOutput)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnAgentEnd failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnEnd(childCtx, contextWrapper, agent, finalOutput)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnEnd failed: %w", err)
			}
		}()
	}

	wg.Wait()
	return errors.Join(hooksErrors[:]...)
}

func (runImpl) RunSingleInputGuardrail(
	ctx context.Context,
	agent *Agent,
	guardrail InputGuardrail,
	input Input,
	contextWrapper *runcontext.RunContextWrapper,
) (InputGuardrailResult, error) {
	return guardrail.Run(ctx, agent, input, contextWrapper)
}

func (runImpl) RunSingleOutputGuardrail(
	ctx context.Context,
	guardrail OutputGuardrail,
	agent *Agent,
	agentOutput any,
	contextWrapper *runcontext.RunContextWrapper,
) (OutputGuardrailResult, error) {
	return guardrail.Run(ctx, contextWrapper, agent, agentOutput)
}

func (runImpl) StreamStepResultToQueue(stepResult SingleStepResult, queue *asyncqueue.Queue[StreamEvent]) {
	for _, item := range stepResult.NewStepItems {
		var event StreamEvent

		switch item.(type) {
		case MessageOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventMessageOutputCreated,
				Item: item,
				Type: "run_item_stream_event",
			}
		case HandoffCallItem:
			event = RunItemStreamEvent{
				Name: StreamEventHandoffRequested,
				Item: item,
				Type: "run_item_stream_event",
			}
		case HandoffOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventHandoffOccurred,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ToolCallItem:
			event = RunItemStreamEvent{
				Name: StreamEventToolCalled,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ToolCallOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventToolOutput,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ReasoningItem:
			event = RunItemStreamEvent{
				Name: StreamEventReasoningItemCreated,
				Item: item,
				Type: "run_item_stream_event",
			}
		default:
			// This would be an unrecoverable implementation bug, so a panic is appropriate.
			panic(fmt.Errorf("unexpected RunItem type %T", item))
		}

		queue.Put(event)
	}
}

// Returns (i, final_output).
func (runImpl) checkForFinalOutputFromTools(
	agent *Agent,
	toolResults []FunctionToolResult,
	contextWrapper *runcontext.RunContextWrapper,
) (ToolsToFinalOutputResult, error) {
	if len(toolResults) == 0 {
		return notFinalOutput, nil
	}

	toolUseBehavior := agent.ToolUseBehavior
	if toolUseBehavior == nil {
		toolUseBehavior = RunLLMAgain{}
	}

	switch v := toolUseBehavior.(type) {
	case RunLLMAgain:
		return notFinalOutput, nil
	case StopOnFirstTool:
		return ToolsToFinalOutputResult{
			IsFinalOutput: true,
			FinalOutput:   optional.Value(toolResults[0].Output),
		}, nil
	case StopAtTools:
		for _, toolResult := range toolResults {
			if slices.Contains(v.StopAtToolNames, toolResult.Tool.Name) {
				return ToolsToFinalOutputResult{
					IsFinalOutput: true,
					FinalOutput:   optional.Value(toolResult.Output),
				}, nil
			}
		}
		return notFinalOutput, nil
	case ToolsToFinalOutputFunction:
		return v(contextWrapper, toolResults)
	default:
		// This would be an unrecoverable implementation bug, so a panic is appropriate.
		panic(fmt.Errorf("unexpected ToolUseBehavior type %T", v))
	}
}
